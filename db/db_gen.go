// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"testing"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
	_ "golang.org/x/text/cases"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_telegramID UserWithPrismaTelegramIDSetParam,
	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _telegramID.field())
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() userManyTxResult {
	v := NewuserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_telegramID UserWithPrismaTelegramIDSetParam,
	_firstName UserWithPrismaFirstNameSetParam,
	_lastName UserWithPrismaLastNameSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _telegramID.field())
	fields = append(fields, _firstName.field())
	fields = append(fields, _lastName.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() userUniqueTxResult {
	v := NewuserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template enums.gotpl ---

type UserType string

const (
	UserTypeUser  UserType = "USER"
	UserTypeAdmin UserType = "ADMIN"
)

type RawUserType UserType

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID         UserScalarFieldEnum = "id"
	UserScalarFieldEnumTelegramID UserScalarFieldEnum = "telegramID"
	UserScalarFieldEnumFirstName  UserScalarFieldEnum = "firstName"
	UserScalarFieldEnumLastName   UserScalarFieldEnum = "lastName"
	UserScalarFieldEnumUsername   UserScalarFieldEnum = "username"
	UserScalarFieldEnumLanguage   UserScalarFieldEnum = "language"
	UserScalarFieldEnumUserType   UserScalarFieldEnum = "userType"
	UserScalarFieldEnumCreatedAt  UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt  UserScalarFieldEnum = "updatedAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "telegramID"},
	{Name: "firstName"},
	{Name: "lastName"},
	{Name: "username"},
	{Name: "language"},
	{Name: "userType"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaTelegramIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	telegramIDField()
}

type UserWithPrismaTelegramIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	telegramIDField()
}

type userWithPrismaTelegramIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTelegramIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTelegramIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTelegramIDSetParam) userModel() {}

func (p userWithPrismaTelegramIDSetParam) telegramIDField() {}

type UserWithPrismaTelegramIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	telegramIDField()
}

type userWithPrismaTelegramIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTelegramIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTelegramIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTelegramIDEqualsParam) userModel() {}

func (p userWithPrismaTelegramIDEqualsParam) telegramIDField() {}

func (userWithPrismaTelegramIDSetParam) settable()  {}
func (userWithPrismaTelegramIDEqualsParam) equals() {}

type userWithPrismaTelegramIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTelegramIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTelegramIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTelegramIDEqualsUniqueParam) userModel()       {}
func (p userWithPrismaTelegramIDEqualsUniqueParam) telegramIDField() {}

func (userWithPrismaTelegramIDEqualsUniqueParam) unique() {}
func (userWithPrismaTelegramIDEqualsUniqueParam) equals() {}

type UserWithPrismaFirstNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	firstNameField()
}

type UserWithPrismaFirstNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameSetParam) userModel() {}

func (p userWithPrismaFirstNameSetParam) firstNameField() {}

type UserWithPrismaFirstNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	firstNameField()
}

type userWithPrismaFirstNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsParam) userModel() {}

func (p userWithPrismaFirstNameEqualsParam) firstNameField() {}

func (userWithPrismaFirstNameSetParam) settable()  {}
func (userWithPrismaFirstNameEqualsParam) equals() {}

type userWithPrismaFirstNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFirstNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFirstNameEqualsUniqueParam) userModel()      {}
func (p userWithPrismaFirstNameEqualsUniqueParam) firstNameField() {}

func (userWithPrismaFirstNameEqualsUniqueParam) unique() {}
func (userWithPrismaFirstNameEqualsUniqueParam) equals() {}

type UserWithPrismaLastNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	lastNameField()
}

type UserWithPrismaLastNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameSetParam) userModel() {}

func (p userWithPrismaLastNameSetParam) lastNameField() {}

type UserWithPrismaLastNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	lastNameField()
}

type userWithPrismaLastNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsParam) userModel() {}

func (p userWithPrismaLastNameEqualsParam) lastNameField() {}

func (userWithPrismaLastNameSetParam) settable()  {}
func (userWithPrismaLastNameEqualsParam) equals() {}

type userWithPrismaLastNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLastNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLastNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLastNameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaLastNameEqualsUniqueParam) lastNameField() {}

func (userWithPrismaLastNameEqualsUniqueParam) unique() {}
func (userWithPrismaLastNameEqualsUniqueParam) equals() {}

type UserWithPrismaUsernameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	usernameField()
}

type UserWithPrismaUsernameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameSetParam) userModel() {}

func (p userWithPrismaUsernameSetParam) usernameField() {}

type UserWithPrismaUsernameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsParam) userModel() {}

func (p userWithPrismaUsernameEqualsParam) usernameField() {}

func (userWithPrismaUsernameSetParam) settable()  {}
func (userWithPrismaUsernameEqualsParam) equals() {}

type userWithPrismaUsernameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaUsernameEqualsUniqueParam) usernameField() {}

func (userWithPrismaUsernameEqualsUniqueParam) unique() {}
func (userWithPrismaUsernameEqualsUniqueParam) equals() {}

type UserWithPrismaLanguageEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	languageField()
}

type UserWithPrismaLanguageSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	languageField()
}

type userWithPrismaLanguageSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLanguageSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLanguageSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLanguageSetParam) userModel() {}

func (p userWithPrismaLanguageSetParam) languageField() {}

type UserWithPrismaLanguageWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	languageField()
}

type userWithPrismaLanguageEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLanguageEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLanguageEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLanguageEqualsParam) userModel() {}

func (p userWithPrismaLanguageEqualsParam) languageField() {}

func (userWithPrismaLanguageSetParam) settable()  {}
func (userWithPrismaLanguageEqualsParam) equals() {}

type userWithPrismaLanguageEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLanguageEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLanguageEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLanguageEqualsUniqueParam) userModel()     {}
func (p userWithPrismaLanguageEqualsUniqueParam) languageField() {}

func (userWithPrismaLanguageEqualsUniqueParam) unique() {}
func (userWithPrismaLanguageEqualsUniqueParam) equals() {}

type UserWithPrismaUserTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	userTypeField()
}

type UserWithPrismaUserTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	userTypeField()
}

type userWithPrismaUserTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserTypeSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserTypeSetParam) userModel() {}

func (p userWithPrismaUserTypeSetParam) userTypeField() {}

type UserWithPrismaUserTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	userTypeField()
}

type userWithPrismaUserTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserTypeEqualsParam) userModel() {}

func (p userWithPrismaUserTypeEqualsParam) userTypeField() {}

func (userWithPrismaUserTypeSetParam) settable()  {}
func (userWithPrismaUserTypeEqualsParam) equals() {}

type userWithPrismaUserTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserTypeEqualsUniqueParam) userModel()     {}
func (p userWithPrismaUserTypeEqualsUniqueParam) userTypeField() {}

func (userWithPrismaUserTypeEqualsUniqueParam) unique() {}
func (userWithPrismaUserTypeEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID         string   `json:"id"`
	TelegramID BigInt   `json:"telegramID"`
	FirstName  string   `json:"firstName"`
	LastName   string   `json:"lastName"`
	Username   string   `json:"username"`
	Language   string   `json:"language"`
	UserType   UserType `json:"userType"`
	CreatedAt  DateTime `json:"createdAt"`
	UpdatedAt  DateTime `json:"updatedAt"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID         RawString   `json:"id"`
	TelegramID RawBigInt   `json:"telegramID"`
	FirstName  RawString   `json:"firstName"`
	LastName   RawString   `json:"lastName"`
	Username   RawString   `json:"username"`
	Language   RawString   `json:"language"`
	UserType   RawUserType `json:"userType"`
	CreatedAt  RawDateTime `json:"createdAt"`
	UpdatedAt  RawDateTime `json:"updatedAt"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// TelegramID
	//
	// @required
	// @unique
	TelegramID userQueryTelegramIDBigInt

	// FirstName
	//
	// @required
	FirstName userQueryFirstNameString

	// LastName
	//
	// @required
	LastName userQueryLastNameString

	// Username
	//
	// @required
	Username userQueryUsernameString

	// Language
	//
	// @required
	Language userQueryLanguageString

	// UserType
	//
	// @required
	UserType userQueryUserTypeUserType

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryTelegramIDBigInt struct{}

// Set the required value of TelegramID
func (r userQueryTelegramIDBigInt) Set(value BigInt) userWithPrismaTelegramIDSetParam {

	return userWithPrismaTelegramIDSetParam{
		data: builder.Field{
			Name:  "telegramID",
			Value: value,
		},
	}

}

// Set the optional value of TelegramID dynamically
func (r userQueryTelegramIDBigInt) SetIfPresent(value *BigInt) userWithPrismaTelegramIDSetParam {
	if value == nil {
		return userWithPrismaTelegramIDSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of TelegramID
func (r userQueryTelegramIDBigInt) Increment(value BigInt) userWithPrismaTelegramIDSetParam {
	return userWithPrismaTelegramIDSetParam{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) IncrementIfPresent(value *BigInt) userWithPrismaTelegramIDSetParam {
	if value == nil {
		return userWithPrismaTelegramIDSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of TelegramID
func (r userQueryTelegramIDBigInt) Decrement(value BigInt) userWithPrismaTelegramIDSetParam {
	return userWithPrismaTelegramIDSetParam{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) DecrementIfPresent(value *BigInt) userWithPrismaTelegramIDSetParam {
	if value == nil {
		return userWithPrismaTelegramIDSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of TelegramID
func (r userQueryTelegramIDBigInt) Multiply(value BigInt) userWithPrismaTelegramIDSetParam {
	return userWithPrismaTelegramIDSetParam{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) MultiplyIfPresent(value *BigInt) userWithPrismaTelegramIDSetParam {
	if value == nil {
		return userWithPrismaTelegramIDSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of TelegramID
func (r userQueryTelegramIDBigInt) Divide(value BigInt) userWithPrismaTelegramIDSetParam {
	return userWithPrismaTelegramIDSetParam{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) DivideIfPresent(value *BigInt) userWithPrismaTelegramIDSetParam {
	if value == nil {
		return userWithPrismaTelegramIDSetParam{}
	}
	return r.Divide(*value)
}

func (r userQueryTelegramIDBigInt) Equals(value BigInt) userWithPrismaTelegramIDEqualsUniqueParam {

	return userWithPrismaTelegramIDEqualsUniqueParam{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) EqualsIfPresent(value *BigInt) userWithPrismaTelegramIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaTelegramIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryTelegramIDBigInt) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "telegramID",
			Value: direction,
		},
	}
}

func (r userQueryTelegramIDBigInt) Cursor(cursor BigInt) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "telegramID",
			Value: cursor,
		},
	}
}

func (r userQueryTelegramIDBigInt) In(value []BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) InIfPresent(value []BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryTelegramIDBigInt) NotIn(value []BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) NotInIfPresent(value []BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryTelegramIDBigInt) Lt(value BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) LtIfPresent(value *BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryTelegramIDBigInt) Lte(value BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) LteIfPresent(value *BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryTelegramIDBigInt) Gt(value BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) GtIfPresent(value *BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryTelegramIDBigInt) Gte(value BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) GteIfPresent(value *BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryTelegramIDBigInt) Not(value BigInt) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "telegramID",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryTelegramIDBigInt) NotIfPresent(value *BigInt) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// base struct
type userQueryFirstNameString struct{}

// Set the required value of FirstName
func (r userQueryFirstNameString) Set(value string) userWithPrismaFirstNameSetParam {

	return userWithPrismaFirstNameSetParam{
		data: builder.Field{
			Name:  "firstName",
			Value: value,
		},
	}

}

// Set the optional value of FirstName dynamically
func (r userQueryFirstNameString) SetIfPresent(value *string) userWithPrismaFirstNameSetParam {
	if value == nil {
		return userWithPrismaFirstNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryFirstNameString) Equals(value string) userWithPrismaFirstNameEqualsParam {

	return userWithPrismaFirstNameEqualsParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EqualsIfPresent(value *string) userWithPrismaFirstNameEqualsParam {
	if value == nil {
		return userWithPrismaFirstNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryFirstNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "firstName",
			Value: direction,
		},
	}
}

func (r userQueryFirstNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "firstName",
			Value: cursor,
		},
	}
}

func (r userQueryFirstNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryFirstNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryFirstNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryFirstNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryFirstNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryFirstNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryFirstNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryFirstNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryFirstNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryFirstNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryFirstNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFirstNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryFirstNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryFirstNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryFirstNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "firstName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryFirstNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryLastNameString struct{}

// Set the required value of LastName
func (r userQueryLastNameString) Set(value string) userWithPrismaLastNameSetParam {

	return userWithPrismaLastNameSetParam{
		data: builder.Field{
			Name:  "lastName",
			Value: value,
		},
	}

}

// Set the optional value of LastName dynamically
func (r userQueryLastNameString) SetIfPresent(value *string) userWithPrismaLastNameSetParam {
	if value == nil {
		return userWithPrismaLastNameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryLastNameString) Equals(value string) userWithPrismaLastNameEqualsParam {

	return userWithPrismaLastNameEqualsParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EqualsIfPresent(value *string) userWithPrismaLastNameEqualsParam {
	if value == nil {
		return userWithPrismaLastNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryLastNameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "lastName",
			Value: direction,
		},
	}
}

func (r userQueryLastNameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "lastName",
			Value: cursor,
		},
	}
}

func (r userQueryLastNameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryLastNameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryLastNameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryLastNameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryLastNameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryLastNameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryLastNameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryLastNameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryLastNameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryLastNameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryLastNameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLastNameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryLastNameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryLastNameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryLastNameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "lastName",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryLastNameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryUsernameString struct{}

// Set the required value of Username
func (r userQueryUsernameString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "username",
			Value: value,
		},
	}

}

// Set the optional value of Username dynamically
func (r userQueryUsernameString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUsernameString) Equals(value string) userWithPrismaUsernameEqualsParam {

	return userWithPrismaUsernameEqualsParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EqualsIfPresent(value *string) userWithPrismaUsernameEqualsParam {
	if value == nil {
		return userWithPrismaUsernameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUsernameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "username",
			Value: direction,
		},
	}
}

func (r userQueryUsernameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "username",
			Value: cursor,
		},
	}
}

func (r userQueryUsernameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUsernameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUsernameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUsernameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUsernameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUsernameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUsernameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryUsernameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryUsernameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryUsernameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryUsernameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryUsernameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryUsernameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryUsernameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryUsernameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryLanguageString struct{}

// Set the required value of Language
func (r userQueryLanguageString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "language",
			Value: value,
		},
	}

}

// Set the optional value of Language dynamically
func (r userQueryLanguageString) SetIfPresent(value *string) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryLanguageString) Equals(value string) userWithPrismaLanguageEqualsParam {

	return userWithPrismaLanguageEqualsParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) EqualsIfPresent(value *string) userWithPrismaLanguageEqualsParam {
	if value == nil {
		return userWithPrismaLanguageEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryLanguageString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "language",
			Value: direction,
		},
	}
}

func (r userQueryLanguageString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "language",
			Value: cursor,
		},
	}
}

func (r userQueryLanguageString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryLanguageString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryLanguageString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryLanguageString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryLanguageString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryLanguageString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryLanguageString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryLanguageString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryLanguageString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryLanguageString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryLanguageString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryLanguageString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryLanguageString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryLanguageString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryLanguageString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryLanguageString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type userQueryUserTypeUserType struct{}

// Set the required value of UserType
func (r userQueryUserTypeUserType) Set(value UserType) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "userType",
			Value: value,
		},
	}

}

// Set the optional value of UserType dynamically
func (r userQueryUserTypeUserType) SetIfPresent(value *UserType) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUserTypeUserType) Equals(value UserType) userWithPrismaUserTypeEqualsParam {

	return userWithPrismaUserTypeEqualsParam{
		data: builder.Field{
			Name: "userType",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUserTypeUserType) EqualsIfPresent(value *UserType) userWithPrismaUserTypeEqualsParam {
	if value == nil {
		return userWithPrismaUserTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUserTypeUserType) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "userType",
			Value: direction,
		},
	}
}

func (r userQueryUserTypeUserType) Cursor(cursor UserType) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "userType",
			Value: cursor,
		},
	}
}

func (r userQueryUserTypeUserType) In(value []UserType) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "userType",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUserTypeUserType) InIfPresent(value []UserType) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUserTypeUserType) NotIn(value []UserType) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "userType",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUserTypeUserType) NotInIfPresent(value []UserType) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUserTypeUserType) Not(value UserType) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "userType",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUserTypeUserType) NotIfPresent(value *UserType) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// --- template transaction.gotpl ---

func NewuserUniqueTxResult() userUniqueTxResult {
	return userUniqueTxResult{
		result: &transaction.Result{},
	}
}

type userUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userUniqueTxResult) IsTx() {}

func (r userUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewuserManyTxResult() userManyTxResult {
	return userManyTxResult{
		result: &transaction.Result{},
	}
}

type userManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p userManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p userManyTxResult) IsTx() {}

func (r userManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template client.gotpl ---
const schema = `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

enum UserType {
  USER
  ADMIN
}

model User {
  id         String   @id @default(cuid())
  telegramID BigInt   @unique
  firstName  String
  lastName   String
  username   String   @default("none")
  language   String   @default("en")
  userType   UserType @default(USER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
`
const schemaConnectionURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient() *PrismaClient {
	c := newClient()

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
}
